<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>Penalized PPML Regression with penppml</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Penalized PPML Regression with penppml</h1>


<div id="TOC">
<ul>
<li><a href="#introduction" id="toc-introduction"><span class="toc-section-number">1</span> Introduction</a></li>
<li><a href="#data-sets" id="toc-data-sets"><span class="toc-section-number">2</span> Data Sets</a></li>
<li><a href="#unpenalized-ppml-estimation-with-hdfe" id="toc-unpenalized-ppml-estimation-with-hdfe"><span class="toc-section-number">3</span> Unpenalized PPML estimation with
HDFE</a></li>
<li><a href="#penalized-ppml-estimation-with-hdfe" id="toc-penalized-ppml-estimation-with-hdfe"><span class="toc-section-number">4</span> Penalized PPML estimation with
HDFE</a>
<ul>
<li><a href="#lasso-regression" id="toc-lasso-regression"><span class="toc-section-number">4.1</span> Lasso regression</a></li>
<li><a href="#ridge-regression-in-development" id="toc-ridge-regression-in-development"><span class="toc-section-number">4.2</span> Ridge regression (in
development)</a></li>
<li><a href="#penalty-selection" id="toc-penalty-selection"><span class="toc-section-number">4.3</span> Penalty selection</a>
<ul>
<li><a href="#cross-validation" id="toc-cross-validation"><span class="toc-section-number">4.3.1</span> Cross-validation</a></li>
<li><a href="#plugin-lasso" id="toc-plugin-lasso"><span class="toc-section-number">4.3.2</span> Plugin lasso</a></li>
<li><a href="#iceberg-lasso-in-development" id="toc-iceberg-lasso-in-development"><span class="toc-section-number">4.3.3</span> Iceberg lasso (in
development)</a></li>
</ul></li>
</ul></li>
<li><a href="#bootstrap-lasso" id="toc-bootstrap-lasso"><span class="toc-section-number">5</span> Bootstrap Lasso</a></li>
<li><a href="#references" id="toc-references"><span class="toc-section-number">6</span> References</a></li>
</ul>
</div>

<div id="introduction" class="section level1" number="1">
<h1><span class="header-section-number">1</span> Introduction</h1>
<p><code>penppml</code> is an R package that enables users to fit
penalized Poisson Pseudo Maximum Likelihood (PPML) regressions with
high-dimensional fixed effects (HDFE). Supported penalties in the
current version are ridge and lasso. The original application that
motivated the development of <code>penppml</code> was the estimation of
three-way gravity models of trade with a large number of PTA provision
dummies (Breinlich, Corradi, Rocha, Ruta, Santos Silva and Zylkin,
2021).</p>
<p>To install and load <code>penppml</code>, you can use the following
commands:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="fu">install.packages</span>(<span class="st">&quot;penppml&quot;</span>)</span></code></pre></div>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="fu">library</span>(penppml)</span></code></pre></div>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a>devtools<span class="sc">::</span><span class="fu">load_all</span>()</span></code></pre></div>
</div>
<div id="data-sets" class="section level1" number="2">
<h1><span class="header-section-number">2</span> Data Sets</h1>
<p>The <code>penppml</code> package features the <code>trade</code> data
set, which integrates panel data on bilateral trade flows with
information about specific provisions in trade agreements for 220
exporters and 270 importers. The provisions included in the package are
a subset of 16 out of 305 “essential” provisions featured in the full
data set. More information about the data set and the variables is
included in the corresponding help file, accessible via
<code>?trade</code>.</p>
<p>Along with the <code>trade</code> data set, the package includes an
auxiliary data frame, <code>countries</code>, which contains basic
information about the country ISO codes included in the main data
set.</p>
<p>This enables users to easily filter by region or subregion. For
instance, if we want to restrict our analysis to countries in the
Americas, we can do the following:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a>selected <span class="ot">&lt;-</span> countries<span class="sc">$</span>iso[countries<span class="sc">$</span>region <span class="sc">%in%</span> <span class="fu">c</span>(<span class="st">&quot;Americas&quot;</span>)]</span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a>trade2 <span class="ot">&lt;-</span> trade[(trade<span class="sc">$</span>exp <span class="sc">%in%</span> selected) <span class="sc">&amp;</span> (trade<span class="sc">$</span>imp <span class="sc">%in%</span> selected), <span class="sc">-</span>(<span class="dv">5</span><span class="sc">:</span><span class="dv">6</span>)] <span class="co"># We remove columns 5 and </span></span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a><span class="co"># 6 because these variables are not needed in our regressions.</span></span></code></pre></div>
<p>We will show the capabilities of this package using the filtered
<code>trade2</code> data frame.</p>
</div>
<div id="unpenalized-ppml-estimation-with-hdfe" class="section level1" number="3">
<h1><span class="header-section-number">3</span> Unpenalized PPML
estimation with HDFE</h1>
<p>The package enables users to run unpenalized PPML regressions with
HDFE, using the <code>hdfeppml</code> function as follows:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a>reg1 <span class="ot">&lt;-</span> <span class="fu">hdfeppml</span>(<span class="at">data =</span> trade2,</span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a>                 <span class="at">dep =</span> <span class="st">&quot;export&quot;</span>,</span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a>                 <span class="at">fixed =</span> <span class="fu">list</span>(<span class="fu">c</span>(<span class="st">&quot;exp&quot;</span>, <span class="st">&quot;time&quot;</span>), </span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a>                              <span class="fu">c</span>(<span class="st">&quot;imp&quot;</span>, <span class="st">&quot;time&quot;</span>),</span>
<span id="cb5-5"><a href="#cb5-5" tabindex="-1"></a>                              <span class="fu">c</span>(<span class="st">&quot;exp&quot;</span>, <span class="st">&quot;imp&quot;</span>)))</span></code></pre></div>
<p>As we can see, the function is designed to be data-frame-friendly:
the user sets a data frame of reference in the <code>data</code>
argument and then picks the dependent, independent and fixed effect
variables either by name or by column number within the provided data
frame. Also, note the following points about the syntax:</p>
<ul>
<li><p>The <code>fixed</code> argument can take either a single vector
(just like the <code>dep</code> argument; each element will be used as a
separate fixed effect) or a list of vectors. The latter option is useful
in cases where the desired fixed effect is the result of the interaction
of two or more variables, as in the gravity model of trade. In those
cases, you can specify any number of separate fixed effects in distinct
elements of the list and, inside each element, which variables in the
data set you want to interact.</p></li>
<li><p>As explained in the note, if <code>indep</code> is empty, the
function uses all remaining columns in the data frame by
default.</p></li>
</ul>
<p>Internally, the function will do the necessary transformations of the
columns into vectors and matrices, as needed by the algorithm.</p>
<p>Alternatively, more advanced users who prefer to handle data
transformations themselves can use the internal function
<code>hdfeppml_int</code>. For more information and examples on this
issue, run <code>?hdfeppml</code> or <code>?hdfeppml_int</code>. Note
also that this applies to all of the main functions in our package: both
the data-frame-friendly wrapper and the internal function are available
for use.</p>
<p>To obtain the results associated with our PPML model:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a>results <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">prov =</span> <span class="fu">rownames</span>(reg1<span class="sc">$</span>coefficients), <span class="at">b =</span> reg1<span class="sc">$</span>coefficients, <span class="at">se =</span> <span class="dv">0</span>)</span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a>results<span class="sc">$</span>se[<span class="sc">!</span><span class="fu">is.na</span>(reg1<span class="sc">$</span>coefficients)] <span class="ot">&lt;-</span> reg1<span class="sc">$</span>se</span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a>results</span></code></pre></div>
<p>If we want to specify the independent variable, we can specify indep
as pointing to columns 5 to 7 with the following code.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a>reg1_indep <span class="ot">&lt;-</span> <span class="fu">hdfeppml</span>(<span class="at">data =</span> trade2, <span class="at">indep=</span><span class="dv">5</span><span class="sc">:</span><span class="dv">7</span>,</span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a>                 <span class="at">dep =</span> <span class="st">&quot;export&quot;</span>,</span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a>                 <span class="at">fixed =</span> <span class="fu">list</span>(<span class="fu">c</span>(<span class="st">&quot;exp&quot;</span>, <span class="st">&quot;time&quot;</span>), </span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a>                              <span class="fu">c</span>(<span class="st">&quot;imp&quot;</span>, <span class="st">&quot;time&quot;</span>),</span>
<span id="cb7-5"><a href="#cb7-5" tabindex="-1"></a>                              <span class="fu">c</span>(<span class="st">&quot;exp&quot;</span>, <span class="st">&quot;imp&quot;</span>)))</span></code></pre></div>
</div>
<div id="penalized-ppml-estimation-with-hdfe" class="section level1" number="4">
<h1><span class="header-section-number">4</span> Penalized PPML
estimation with HDFE</h1>
<div id="lasso-regression" class="section level2" number="4.1">
<h2><span class="header-section-number">4.1</span> Lasso regression</h2>
<p>The <code>mlfitppml</code> function is a flexible tool for computing
penalized PPML regressions with HDFE. For instance, if we want to fit a
PPML regression with a lasso penalty for several values of the penalty
parameter (lambda) at once, we can run:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a>lambdas <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">0.05</span>, <span class="fl">0.025</span>, <span class="fl">0.01</span>, <span class="fl">0.0075</span>, <span class="fl">0.005</span>, <span class="fl">0.0025</span>, <span class="fl">0.001</span>, <span class="fl">0.00075</span>, <span class="fl">0.0005</span>, <span class="fl">0.00025</span>, <span class="fl">0.0001</span>, <span class="dv">0</span>)</span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a>reg2 <span class="ot">&lt;-</span> <span class="fu">mlfitppml</span>(<span class="at">data =</span> trade2,</span>
<span id="cb8-4"><a href="#cb8-4" tabindex="-1"></a>                  <span class="at">dep =</span> <span class="st">&quot;export&quot;</span>,</span>
<span id="cb8-5"><a href="#cb8-5" tabindex="-1"></a>                  <span class="at">fixed =</span> <span class="fu">list</span>(<span class="fu">c</span>(<span class="st">&quot;exp&quot;</span>, <span class="st">&quot;time&quot;</span>), </span>
<span id="cb8-6"><a href="#cb8-6" tabindex="-1"></a>                              <span class="fu">c</span>(<span class="st">&quot;imp&quot;</span>, <span class="st">&quot;time&quot;</span>),</span>
<span id="cb8-7"><a href="#cb8-7" tabindex="-1"></a>                              <span class="fu">c</span>(<span class="st">&quot;exp&quot;</span>, <span class="st">&quot;imp&quot;</span>)),</span>
<span id="cb8-8"><a href="#cb8-8" tabindex="-1"></a>                  <span class="at">penalty =</span> <span class="st">&quot;lasso&quot;</span>,</span>
<span id="cb8-9"><a href="#cb8-9" tabindex="-1"></a>                  <span class="at">lambdas =</span> lambdas)</span></code></pre></div>
<p>The function returns a list that contains two sets of coefficients
for each value of lambda: the penalized coefficients (in the
<code>beta_pre</code> element) and the post-penalty or unpenalized
coefficients (in the <code>beta</code> element; these are calculated by
estimating a post-penalty regression with just the selected
variables).</p>
<p>If the user wishes to obtain the penalized estimates for a single
value of lambda, they can either use <code>mlfitppml</code> as described
above (just setting <code>lambdas == x</code>, where <code>x</code> is a
number) or use the <code>penhdfeppml</code> function, upon which
<code>mlfitppml</code> is built, directly. For instance:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a>reg3 <span class="ot">&lt;-</span> <span class="fu">penhdfeppml</span>(<span class="at">data =</span> trade2,</span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a>                  <span class="at">dep =</span> <span class="st">&quot;export&quot;</span>,</span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a>                  <span class="at">fixed =</span> <span class="fu">list</span>(<span class="fu">c</span>(<span class="st">&quot;exp&quot;</span>, <span class="st">&quot;time&quot;</span>), </span>
<span id="cb9-4"><a href="#cb9-4" tabindex="-1"></a>                              <span class="fu">c</span>(<span class="st">&quot;imp&quot;</span>, <span class="st">&quot;time&quot;</span>),</span>
<span id="cb9-5"><a href="#cb9-5" tabindex="-1"></a>                              <span class="fu">c</span>(<span class="st">&quot;exp&quot;</span>, <span class="st">&quot;imp&quot;</span>)),</span>
<span id="cb9-6"><a href="#cb9-6" tabindex="-1"></a>                  <span class="at">penalty =</span> <span class="st">&quot;lasso&quot;</span>,</span>
<span id="cb9-7"><a href="#cb9-7" tabindex="-1"></a>                  <span class="at">lambda =</span> <span class="fl">0.005</span>)</span></code></pre></div>
<p>For more details on <code>penhdfeppml</code>, run
<code>?penhdfeppml</code>.</p>
</div>
<div id="ridge-regression-in-development" class="section level2" number="4.2">
<h2><span class="header-section-number">4.2</span> Ridge regression (in
development)</h2>
<p><code>mlfitppml</code> also allows user to use the ridge penalty in
their PPML regressions. Simply run:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a>lambdas <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="fl">0.0001</span>, <span class="dv">0</span>, <span class="at">length.out =</span> <span class="dv">10</span>) </span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" tabindex="-1"></a>reg4 <span class="ot">&lt;-</span> <span class="fu">mlfitppml</span>(<span class="at">data =</span> trade2,</span>
<span id="cb10-4"><a href="#cb10-4" tabindex="-1"></a>                  <span class="at">dep =</span> <span class="st">&quot;export&quot;</span>,</span>
<span id="cb10-5"><a href="#cb10-5" tabindex="-1"></a>                  <span class="at">fixed =</span> <span class="fu">list</span>(<span class="fu">c</span>(<span class="st">&quot;exp&quot;</span>, <span class="st">&quot;time&quot;</span>), </span>
<span id="cb10-6"><a href="#cb10-6" tabindex="-1"></a>                              <span class="fu">c</span>(<span class="st">&quot;imp&quot;</span>, <span class="st">&quot;time&quot;</span>),</span>
<span id="cb10-7"><a href="#cb10-7" tabindex="-1"></a>                              <span class="fu">c</span>(<span class="st">&quot;exp&quot;</span>, <span class="st">&quot;imp&quot;</span>)),</span>
<span id="cb10-8"><a href="#cb10-8" tabindex="-1"></a>                  <span class="at">penalty =</span> <span class="st">&quot;ridge&quot;</span>,</span>
<span id="cb10-9"><a href="#cb10-9" tabindex="-1"></a>                  <span class="at">lambdas =</span> lambdas)</span></code></pre></div>
<p>Note that this feature is still in development and may contain
bugs.</p>
</div>
<div id="penalty-selection" class="section level2" number="4.3">
<h2><span class="header-section-number">4.3</span> Penalty
selection</h2>
<div id="cross-validation" class="section level3" number="4.3.1">
<h3><span class="header-section-number">4.3.1</span>
Cross-validation</h3>
<p>The <code>mlfitppml</code> function enables users to carry out
cross-validation of their models via the <code>xval</code> and
<code>IDs</code> arguments. When <code>xval</code> is set to
<code>TRUE</code>, the function performs cross-validation using a
user-provided vector of IDs. For instance, if we want to do k-fold cross
validation with k = 20, splitting the data set by agreement (not by
observation), we can do the following:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a>id <span class="ot">&lt;-</span> <span class="fu">unique</span>(trade[(trade<span class="sc">$</span>exp <span class="sc">%in%</span> selected) <span class="sc">&amp;</span> (trade<span class="sc">$</span>imp <span class="sc">%in%</span> selected), <span class="dv">5</span>])</span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a>nfolds <span class="ot">&lt;-</span> <span class="dv">20</span></span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a>unique_ids <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">id =</span> id, <span class="at">fold =</span> <span class="fu">sample</span>(<span class="dv">1</span><span class="sc">:</span>nfolds, <span class="at">size =</span> <span class="fu">length</span>(id), <span class="at">replace =</span> <span class="cn">TRUE</span>))</span>
<span id="cb11-4"><a href="#cb11-4" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" tabindex="-1"></a>cross_ids <span class="ot">&lt;-</span> <span class="fu">merge</span>(trade[(trade<span class="sc">$</span>exp <span class="sc">%in%</span> selected) <span class="sc">&amp;</span> (trade<span class="sc">$</span>imp <span class="sc">%in%</span> selected), <span class="dv">5</span>, <span class="at">drop =</span> <span class="cn">FALSE</span>], </span>
<span id="cb11-6"><a href="#cb11-6" tabindex="-1"></a>                   unique_ids, <span class="at">by =</span> <span class="st">&quot;id&quot;</span>, <span class="at">all.x =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<p>Now we activate the cross-validation option in <code>mlfitppml</code>
and input the ID vector:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a>reg5 <span class="ot">&lt;-</span> <span class="fu">mlfitppml</span>(<span class="at">data =</span> trade2,</span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a>                  <span class="at">dep =</span> <span class="st">&quot;export&quot;</span>,</span>
<span id="cb12-3"><a href="#cb12-3" tabindex="-1"></a>                  <span class="at">fixed =</span> <span class="fu">list</span>(<span class="fu">c</span>(<span class="st">&quot;exp&quot;</span>, <span class="st">&quot;time&quot;</span>), </span>
<span id="cb12-4"><a href="#cb12-4" tabindex="-1"></a>                              <span class="fu">c</span>(<span class="st">&quot;imp&quot;</span>, <span class="st">&quot;time&quot;</span>),</span>
<span id="cb12-5"><a href="#cb12-5" tabindex="-1"></a>                              <span class="fu">c</span>(<span class="st">&quot;exp&quot;</span>, <span class="st">&quot;imp&quot;</span>)),</span>
<span id="cb12-6"><a href="#cb12-6" tabindex="-1"></a>                  <span class="at">penalty =</span> <span class="st">&quot;lasso&quot;</span>,</span>
<span id="cb12-7"><a href="#cb12-7" tabindex="-1"></a>                  <span class="at">lambdas =</span> <span class="fu">c</span>(<span class="fu">seq</span>(<span class="fl">0.5</span>, <span class="fl">0.1</span>, <span class="at">by =</span> <span class="sc">-</span><span class="fl">0.1</span>), <span class="fl">0.05</span>, <span class="fl">0.01</span>, <span class="fl">0.005</span>, <span class="fl">0.001</span>, <span class="fl">0.0005</span>, <span class="fl">0.0001</span>, <span class="dv">0</span>),</span>
<span id="cb12-8"><a href="#cb12-8" tabindex="-1"></a>                  <span class="at">xval =</span> <span class="cn">TRUE</span>,</span>
<span id="cb12-9"><a href="#cb12-9" tabindex="-1"></a>                  <span class="at">IDs =</span>  cross_ids<span class="sc">$</span>fold)</span></code></pre></div>
<p>Now the function also returns a <code>rmse</code> element that
includes the cross-validation results (the average RMSE or root mean
squared error for each value of lambda). Users can employ this tool to
choose the value of the penalty parameter that minimizes the RMSE:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a>reg5<span class="sc">$</span>rmse</span></code></pre></div>
</div>
<div id="plugin-lasso" class="section level3" number="4.3.2">
<h3><span class="header-section-number">4.3.2</span> Plugin lasso</h3>
<p>This package also enables the use of the plugin lasso method,
incorporating coefficient-specific penalty weights calculated
automatically by the package. The most convenient way to do this is to
set <code>method = &quot;plugin&quot;</code> in <code>mlfitppml</code>. Note that
the plugin algorithm requires a clustering variable - we are using the
interaction of the exporter and importer variables in the
<code>trade</code> data set:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a>reg6 <span class="ot">&lt;-</span> <span class="fu">mlfitppml</span>(<span class="at">data =</span> trade2,</span>
<span id="cb14-2"><a href="#cb14-2" tabindex="-1"></a>                  <span class="at">dep =</span> <span class="st">&quot;export&quot;</span>,</span>
<span id="cb14-3"><a href="#cb14-3" tabindex="-1"></a>                  <span class="at">fixed =</span> <span class="fu">list</span>(<span class="fu">c</span>(<span class="st">&quot;exp&quot;</span>, <span class="st">&quot;time&quot;</span>), </span>
<span id="cb14-4"><a href="#cb14-4" tabindex="-1"></a>                              <span class="fu">c</span>(<span class="st">&quot;imp&quot;</span>, <span class="st">&quot;time&quot;</span>),</span>
<span id="cb14-5"><a href="#cb14-5" tabindex="-1"></a>                              <span class="fu">c</span>(<span class="st">&quot;exp&quot;</span>, <span class="st">&quot;imp&quot;</span>)),</span>
<span id="cb14-6"><a href="#cb14-6" tabindex="-1"></a>                  <span class="at">penalty =</span> <span class="st">&quot;lasso&quot;</span>,</span>
<span id="cb14-7"><a href="#cb14-7" tabindex="-1"></a>                  <span class="at">method =</span> <span class="st">&quot;plugin&quot;</span>,</span>
<span id="cb14-8"><a href="#cb14-8" tabindex="-1"></a>                  <span class="at">cluster =</span> <span class="fu">c</span>(<span class="st">&quot;exp&quot;</span>, <span class="st">&quot;imp&quot;</span>))</span></code></pre></div>
<p>To display the plugin lasso results:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a>results <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">prov =</span> <span class="fu">rownames</span>(reg6<span class="sc">$</span>beta), <span class="at">b_pre =</span> reg6<span class="sc">$</span>beta_pre, <span class="at">b =</span> reg6<span class="sc">$</span>beta, <span class="at">se =</span> <span class="dv">0</span>)</span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a>results<span class="sc">$</span>se <span class="ot">&lt;-</span> reg6<span class="sc">$</span>ses[<span class="dv">1</span>,]</span>
<span id="cb15-3"><a href="#cb15-3" tabindex="-1"></a>results</span></code></pre></div>
<p>We can also set the gamma value as defined in Belloni et al. to
something less strict, e.g. 0.3.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a>reg6_gamma <span class="ot">&lt;-</span> <span class="fu">mlfitppml</span>(<span class="at">data =</span> trade2,</span>
<span id="cb16-2"><a href="#cb16-2" tabindex="-1"></a>                  <span class="at">dep =</span> <span class="st">&quot;export&quot;</span>,</span>
<span id="cb16-3"><a href="#cb16-3" tabindex="-1"></a>                  <span class="at">fixed =</span> <span class="fu">list</span>(<span class="fu">c</span>(<span class="st">&quot;exp&quot;</span>, <span class="st">&quot;time&quot;</span>), </span>
<span id="cb16-4"><a href="#cb16-4" tabindex="-1"></a>                              <span class="fu">c</span>(<span class="st">&quot;imp&quot;</span>, <span class="st">&quot;time&quot;</span>),</span>
<span id="cb16-5"><a href="#cb16-5" tabindex="-1"></a>                              <span class="fu">c</span>(<span class="st">&quot;exp&quot;</span>, <span class="st">&quot;imp&quot;</span>)),</span>
<span id="cb16-6"><a href="#cb16-6" tabindex="-1"></a>                  <span class="at">penalty =</span> <span class="st">&quot;lasso&quot;</span>,</span>
<span id="cb16-7"><a href="#cb16-7" tabindex="-1"></a>                  <span class="at">method =</span> <span class="st">&quot;plugin&quot;</span>,</span>
<span id="cb16-8"><a href="#cb16-8" tabindex="-1"></a>                  <span class="at">cluster =</span> <span class="fu">c</span>(<span class="st">&quot;exp&quot;</span>, <span class="st">&quot;imp&quot;</span>), <span class="at">gamma_val=</span><span class="fl">0.3</span>)</span>
<span id="cb16-9"><a href="#cb16-9" tabindex="-1"></a><span class="fu">rownames</span>(reg6<span class="sc">$</span>beta)[<span class="fu">which</span>(reg6_gamma<span class="sc">$</span>beta <span class="sc">!=</span> <span class="dv">0</span>)]</span></code></pre></div>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a>results_gamma <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(<span class="at">prov =</span> <span class="fu">rownames</span>(reg6_gamma<span class="sc">$</span>beta), <span class="at">b_pre =</span> reg6_gamma<span class="sc">$</span>beta_pre, <span class="at">b =</span> reg6_gamma<span class="sc">$</span>beta, <span class="at">se =</span> <span class="dv">0</span>)</span>
<span id="cb17-2"><a href="#cb17-2" tabindex="-1"></a>results_gamma<span class="sc">$</span>se <span class="ot">&lt;-</span> reg6_gamma<span class="sc">$</span>ses[<span class="dv">1</span>,]</span>
<span id="cb17-3"><a href="#cb17-3" tabindex="-1"></a>results_gamma</span></code></pre></div>
</div>
<div id="iceberg-lasso-in-development" class="section level3" number="4.3.3">
<h3><span class="header-section-number">4.3.3</span> Iceberg lasso (in
development)</h3>
<p>This package also allows users to implement the two-step lasso
described in Breinlich et al. (2021). This method consists in, first,
running a plugin lasso estimation and second, running individual lasso
regressions on each of the variables selected in the first stage. The
<code>iceberg</code> function is designed precisely with this second
step in mind. It takes a vector of dependent variables and returns a
lasso regression for each one of them:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" tabindex="-1"></a>iceberg_results <span class="ot">&lt;-</span> <span class="fu">iceberg</span>(<span class="at">data =</span> trade2[, <span class="sc">-</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>)],</span>
<span id="cb18-2"><a href="#cb18-2" tabindex="-1"></a>                           <span class="at">dep =</span> results<span class="sc">$</span>prov[results<span class="sc">$</span>b <span class="sc">!=</span> <span class="dv">0</span>],</span>
<span id="cb18-3"><a href="#cb18-3" tabindex="-1"></a>                           <span class="at">selectobs =</span> (trade2<span class="sc">$</span>time <span class="sc">==</span> <span class="st">&quot;2016&quot;</span>))</span></code></pre></div>
<p>Currently, the function returns a matrix with coefficient estimates
for each of the selected provisions. Support for standard errors
(including clustered) is in development as of the current version of the
package.</p>
<p>Since PPML coefficients can’t be easily interpreted, you may find it
useful to see the raw correlations between the variables in the iceberg
lasso step:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a>provcorr <span class="ot">&lt;-</span> <span class="fu">cor</span>(trade2[, results<span class="sc">$</span>prov])</span>
<span id="cb19-2"><a href="#cb19-2" tabindex="-1"></a>(provcorr <span class="ot">&lt;-</span> provcorr[, results<span class="sc">$</span>prov[results<span class="sc">$</span>b <span class="sc">!=</span> <span class="dv">0</span>]])</span></code></pre></div>
</div>
</div>
</div>
<div id="bootstrap-lasso" class="section level1" number="5">
<h1><span class="header-section-number">5</span> Bootstrap Lasso</h1>
<p>To illustrate this, we select the trade data, but now not dropping id
and agreement variable.</p>
<p>We want to cluster by agreement, that means that we draw observations
with the same agreement ID. For this, we need to create a new agreement
ID in the following way:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" tabindex="-1"></a>trade3 <span class="ot">&lt;-</span> trade[(trade<span class="sc">$</span>exp <span class="sc">%in%</span> selected) <span class="sc">&amp;</span> (trade<span class="sc">$</span>imp <span class="sc">%in%</span> selected), ] <span class="co"># Now, we need id and agreement variable</span></span>
<span id="cb20-2"><a href="#cb20-2" tabindex="-1"></a><span class="co"># Let&#39;s cluster by agreement</span></span>
<span id="cb20-3"><a href="#cb20-3" tabindex="-1"></a>trade3<span class="sc">$</span>alt_id <span class="ot">&lt;-</span> trade3<span class="sc">$</span>id <span class="co"># ID refers to agreement ID</span></span>
<span id="cb20-4"><a href="#cb20-4" tabindex="-1"></a>trade3<span class="sc">$</span>alt_id[<span class="fu">is.na</span>(trade3<span class="sc">$</span>alt_id)] <span class="ot">&lt;-</span> <span class="dv">0</span> <span class="co"># We set this to zero when the ID is missing, interpreting this as the country pair not being part of any agreement.</span></span>
<span id="cb20-5"><a href="#cb20-5" tabindex="-1"></a></span>
<span id="cb20-6"><a href="#cb20-6" tabindex="-1"></a><span class="co"># Create pair ID</span></span>
<span id="cb20-7"><a href="#cb20-7" tabindex="-1"></a>v1 <span class="ot">&lt;-</span> <span class="fu">do.call</span>(paste, <span class="fu">as.data.frame</span>(<span class="fu">t</span>(<span class="fu">apply</span>(trade3[<span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>], <span class="dv">1</span>, sort))))</span>
<span id="cb20-8"><a href="#cb20-8" tabindex="-1"></a>trade3<span class="sc">$</span>pair <span class="ot">&lt;-</span>  <span class="fu">match</span>(v1, <span class="fu">unique</span>(v1))</span>
<span id="cb20-9"><a href="#cb20-9" tabindex="-1"></a>trade3<span class="sc">$</span>pair <span class="ot">&lt;-</span> trade3<span class="sc">$</span>pair <span class="sc">+</span> <span class="dv">500</span></span>
<span id="cb20-10"><a href="#cb20-10" tabindex="-1"></a></span>
<span id="cb20-11"><a href="#cb20-11" tabindex="-1"></a></span>
<span id="cb20-12"><a href="#cb20-12" tabindex="-1"></a><span class="co"># Create maximal ID from the preexisting ID-variable inside each pair</span></span>
<span id="cb20-13"><a href="#cb20-13" tabindex="-1"></a>trade3 <span class="ot">&lt;-</span> <span class="fu">within</span>(trade3, {alt_id2 <span class="ot">=</span> <span class="fu">ave</span>(alt_id,pair,<span class="at">FUN=</span>max)} ) <span class="co"># This creates the maximum of the ID for each pair. This adjusts for the fact that some pairs might have been part of different agreements and we want to take get a unique agreement ID for each pair. </span></span>
<span id="cb20-14"><a href="#cb20-14" tabindex="-1"></a></span>
<span id="cb20-15"><a href="#cb20-15" tabindex="-1"></a>trade3<span class="sc">$</span>alt_id2[trade3<span class="sc">$</span>alt_id2<span class="sc">==</span><span class="dv">0</span>] <span class="ot">&lt;-</span> trade3<span class="sc">$</span>pair[trade3<span class="sc">$</span>alt_id2<span class="sc">==</span><span class="dv">0</span>]</span>
<span id="cb20-16"><a href="#cb20-16" tabindex="-1"></a><span class="fu">unique</span>(trade3<span class="sc">$</span>alt_id2) <span class="co"># This cluster variable collects pairs for pairs that are in agreement, uses the pair ID for those that are not.</span></span>
<span id="cb20-17"><a href="#cb20-17" tabindex="-1"></a><span class="co"># Thus, it allows errors to be clustered within agreements.</span></span>
<span id="cb20-18"><a href="#cb20-18" tabindex="-1"></a>alt_id2 <span class="ot">&lt;-</span> <span class="fu">factor</span>(trade3<span class="sc">$</span>alt_id2)</span>
<span id="cb20-19"><a href="#cb20-19" tabindex="-1"></a>trade3<span class="sc">$</span>clus <span class="ot">&lt;-</span> alt_id2 <span class="co">#Add the ID to the data</span></span></code></pre></div>
<p>Next, we run Bootstrap Lasso, which means drawing agreement clusters
with replacement using the ID just created. In the bootstrap() command,
first hdfeppml() is run, using a dummy which is one when any provision
was in place and zero otherwise to get initial values of mu. These are
then used in plugin Lasso. This is repeated B times (as specified in
bootreps) and the command selects those provisions selected by plugin in
at least a fraction of cases. This fraction can be specified by the
option boot_threshold (Default is 1 pc).</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb21-2"><a href="#cb21-2" tabindex="-1"></a>bs1 <span class="ot">&lt;-</span> <span class="fu">bootstrap</span>(<span class="at">data=</span>trade3, <span class="at">dep=</span><span class="st">&quot;export&quot;</span>, <span class="at">cluster_id=</span><span class="st">&quot;clus&quot;</span>, <span class="at">fixed=</span><span class="fu">list</span>(<span class="fu">c</span>(<span class="st">&quot;exp&quot;</span>, <span class="st">&quot;time&quot;</span>), <span class="fu">c</span>(<span class="st">&quot;imp&quot;</span>, <span class="st">&quot;time&quot;</span>), <span class="fu">c</span>(<span class="st">&quot;exp&quot;</span>, <span class="st">&quot;imp&quot;</span>)), <span class="at">indep=</span><span class="dv">7</span><span class="sc">:</span><span class="dv">22</span>, <span class="at">bootreps=</span><span class="dv">10</span>, <span class="at">colcheck_x =</span> <span class="cn">TRUE</span>, <span class="at">colcheck_x_fes =</span> <span class="cn">TRUE</span>, <span class="at">boot_threshold =</span> <span class="fl">0.01</span>, <span class="at">post=</span><span class="cn">TRUE</span>, <span class="at">gamma_val=</span><span class="fl">0.01</span>, <span class="at">verbose=</span><span class="cn">FALSE</span>)</span></code></pre></div>
</div>
<div id="references" class="section level1" number="6">
<h1><span class="header-section-number">6</span> References</h1>
<p>Breinlich, H., Corradi, V., Rocha, N., Ruta, M., Santos Silva, J.M.C.
and T. Zylkin, T. (2021). “Machine Learning in International Trade
Research: Evaluating the Impact of Trade Agreements”, Policy Research
Working Paper; No. 9629. World Bank, Washington, DC.</p>
<p>Correia, S., P. Guimaraes and T. Zylkin (2020). “Fast Poisson
estimation with high dimensional fixed effects”, <em>STATA Journal</em>,
20, 90-115.</p>
<p>Gaure, S (2013). “OLS with multiple high dimensional category
variables”, <em>Computational Statistics &amp; Data Analysis</em>, 66,
8-18.</p>
<p>Friedman, J., T. Hastie, and R. Tibshirani (2010). “Regularization
paths for generalized linear models via coordinate descent”, <em>Journal
of Statistical Software</em>, 33, 1-22.</p>
<p>Belloni, A., V. Chernozhukov, C. Hansen and D. Kozbur (2016).
“Inference in high dimensional panel models with an application to gun
control”, <em>Journal of Business &amp; Economic Statistics</em>, 34,
590-605.</p>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
